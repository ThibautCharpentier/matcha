const { Pool } = require('pg');
const { createReadStream } = require('fs');
const { createInterface } = require('readline');
const dotenv = require('dotenv');

dotenv.config();

const pool = new Pool({
	user: process.env.DB_USER,
	host: process.env.DB_HOST,
	database: process.env.DB_NAME,
	password: process.env.DB_PASSWORD,
	port: process.env.DB_PORT,
});

const createTables = async () => {
	try
	{
		const client = await pool.connect();

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.users (
				id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				username VARCHAR(10) UNIQUE NOT NULL,
				firstname VARCHAR NOT NULL,
				lastname VARCHAR NOT NULL,
				email VARCHAR UNIQUE NOT NULL,
				password VARCHAR NOT NULL,
				verified BOOLEAN DEFAULT false,
				status VARCHAR DEFAULT 'offline',
				last_connection TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				gender VARCHAR,
				preferences VARCHAR DEFAULT 'bi',
				bio TEXT,
				birthdate DATE,
				picture_profile VARCHAR,
				pictures VARCHAR[],
				famerating FLOAT DEFAULT 1,
				gps BOOLEAN DEFAULT false,
				latitude DECIMAL(9, 6),
				longitude DECIMAL(9, 6),
				city VARCHAR
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.chat (
				id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				user1 INTEGER NOT NULL,
				user2 INTEGER NOT NULL,
				FOREIGN KEY (user1) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (user2) REFERENCES public.users(id) ON DELETE CASCADE
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.message (
				chat INTEGER NOT NULL,
				sender INTEGER NOT NULL,
				receiver INTEGER NOT NULL,
				message TEXT NOT NULL,
				created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				view BOOLEAN DEFAULT false,
				FOREIGN KEY (chat) REFERENCES public.chat(id) ON DELETE CASCADE,
				FOREIGN KEY (sender) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (receiver) REFERENCES public.users(id) ON DELETE CASCADE
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.interest (
				id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				name VARCHAR UNIQUE NOT NULL
			)
		`);
		const file = createInterface({
			input: createReadStream("interests.csv")
		});
		for await (const line of file)
            await client.query(`INSERT INTO public.interest (name) VALUES ('${line}') ON CONFLICT (name) DO NOTHING`);
		file.close();

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.user_interest (
				user_id INTEGER NOT NULL,
				interest INTEGER NOT NULL,
				FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (interest) REFERENCES public.interest(id) ON DELETE CASCADE,
				CONSTRAINT unique_user_interest UNIQUE (user_id, interest)
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.interaction (
				user_id INTEGER NOT NULL,
				target INTEGER NOT NULL,
				action VARCHAR,
				updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (target) REFERENCES public.users(id) ON DELETE CASCADE,
				CONSTRAINT unique_interaction UNIQUE (user_id, target)
			)
		`);
		await client.query(`
			CREATE OR REPLACE FUNCTION update_interaction_updated_column()
			RETURNS TRIGGER AS $$
			BEGIN
    		NEW.updated = CURRENT_TIMESTAMP;
    		RETURN NEW;
			END;
			$$ LANGUAGE plpgsql;

			DO $$
			BEGIN
			    IF NOT EXISTS (
			        SELECT 1 FROM pg_trigger
			        WHERE tgname = 'update_interaction_trigger'
			        AND tgrelid = 'public.interaction'::regclass
			    ) THEN
			        CREATE TRIGGER update_interaction_trigger
			        BEFORE UPDATE ON public.interaction
			        FOR EACH ROW EXECUTE FUNCTION update_interaction_updated_column();
			    END IF;
			END $$;
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.view (
				user_id INTEGER NOT NULL,
				target INTEGER NOT NULL,
				created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (target) REFERENCES public.users(id) ON DELETE CASCADE,
				CONSTRAINT unique_view UNIQUE (user_id, target)
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.notification (
				id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				user_id INTEGER NOT NULL,
				from_id INTEGER NOT NULL,
				action VARCHAR,
				verified BOOLEAN DEFAULT false,
				created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (from_id) REFERENCES public.users(id) ON DELETE CASCADE,
				CONSTRAINT unique_notification UNIQUE (user_id, from_id, action)
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.report (
				user_id INTEGER NOT NULL,
				target INTEGER NOT NULL,
				created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
				FOREIGN KEY (target) REFERENCES public.users(id) ON DELETE CASCADE,
				CONSTRAINT unique_report UNIQUE (user_id, target)
			)
		`);

		await client.query(`
			CREATE TABLE IF NOT EXISTS public.admin (
				id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				email VARCHAR UNIQUE NOT NULL,
				code VARCHAR(6)
			)
		`);
		await client.query(`INSERT INTO public.admin (email) VALUES ('${process.env.MAIL_ADMIN1}') ON CONFLICT (email) DO NOTHING`);
		await client.query(`INSERT INTO public.admin (email) VALUES ('${process.env.MAIL_ADMIN2}') ON CONFLICT (email) DO NOTHING`);

		client.release();
	}
	catch (err)
	{
		throw err;
	}
}

const closePool = async () => {
	await pool.end();
}

module.exports = { pool, createTables, closePool };
